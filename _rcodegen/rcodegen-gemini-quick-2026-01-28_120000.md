Date Created: 2026-01-28 12:00:00
TOTAL_SCORE: 82/100

# AUDIT

### 1. Hardcoded Tool Coupling in Orchestrator
**Severity:** High
**Location:** `pkg/orchestrator/orchestrator.go`
**Description:** The `Orchestrator` explicitly imports and instantiates specific tools (`claude`, `codex`, `gemini`) in the `New` function. This violates the Open-Closed Principle, making it difficult to add new tools without modifying the core orchestrator code.
**Recommendation:** Inject the tool registry into `New` or use a plugin/factory pattern that discovers available tools.

### 2. Brittle Report Generation Logic
**Severity:** Medium
**Location:** `pkg/orchestrator/orchestrator.go`
**Description:** Functions like `generateRunReport`, `findStepOutput`, and `extractGradeFromReport` contain hardcoded assumptions about file naming conventions ("docs/draft.md", etc.) and specific bundle types ("article"). This makes the system fragile to changes in bundle structure or output formats.
**Recommendation:** Abstract report generation into a `Reporter` interface. Let the `Bundle` definition drive output paths rather than hardcoding them in the Go code.

### 3. Unsafe Scheduler Implementation
**Severity:** Medium
**Location:** `scheduler/index.js`
**Description:** The scheduler has several robustness issues:
- `writeStatus` lacks error handling (e.g., if disk is full).
- It hardcodes `rcodex` as the command to run.
- It uses `spawn` with `stdio: 'inherit'`, which may fail in background/daemon contexts.
- It assumes a specific timezone ('America/New_York').

### 4. Race Condition in Grade Persistence
**Severity:** Low
**Location:** `pkg/runner/runner.go`
**Description:** `persistGrade` uses a retry loop with `time.Sleep` to find the newest report file generated by a subprocess. This is flaky and relies on filesystem timing.
**Recommendation:** The subprocess should report the generated file path back to the runner (e.g., via stdout/json), or the runner should deterministically know the output path.

---

# TESTS

### 1. Missing Orchestrator Tests
**Description:** `pkg/orchestrator` lacks unit tests for the main `Run` loop and model selection logic.
**Coverage Improvement:** Add `orchestrator_test.go` to verify `getStepModel` logic and basic `Run` flow.

```go
// pkg/orchestrator/orchestrator_test.go

package orchestrator

import (
	"rcodegen/pkg/bundle"
	"rcodegen/pkg/runner"
	"rcodegen/pkg/settings"
	"testing"
)

// MockTool implements runner.Tool for testing
type MockTool struct {
	name         string
	defaultModel string
}

func (m *MockTool) Name() string { return m.name }
func (m *MockTool) DefaultModel() string { return m.defaultModel }
// Implement other interface methods with stubs...
func (m *MockTool) BinaryName() string { return "mock" }
func (m *MockTool) ReportDir() string { return "_rcodegen" }
func (m *MockTool) ReportPrefix() string { return "mock-" }
func (m *MockTool) ValidModels() []string { return []string{m.defaultModel} }
func (m *MockTool) DefaultModelSetting() string { return "mock-default" }
func (m *MockTool) BuildCommand(cfg *runner.Config, workDir, task string) *exec.Cmd { return nil }
func (m *MockTool) ShowStatus() {}
func (m *MockTool) SupportsStatusTracking() bool { return false }
func (m *MockTool) CaptureStatusBefore() interface{} { return nil }
func (m *MockTool) CaptureStatusAfter() interface{} { return nil }
func (m *MockTool) PrintStatusSummary(before, after interface{}) {}
func (m *MockTool) ToolSpecificFlags() []runner.FlagDef { return nil }
func (m *MockTool) ApplyToolDefaults(cfg *runner.Config) {}
func (m *MockTool) PrepareForExecution(cfg *runner.Config) {}
func (m *MockTool) ValidateConfig(cfg *runner.Config) error { return nil }
func (m *MockTool) BannerTitle() string { return "Mock Tool" }
func (m *MockTool) BannerSubtitle() string { return "For Testing" }
func (m *MockTool) PrintToolSpecificBannerFields(cfg *runner.Config) {}
func (m *MockTool) PrintToolSpecificSummaryFields(cfg *runner.Config) {}
func (m *MockTool) SecurityWarning() []string { return nil }
func (m *MockTool) ToolSpecificHelpSections() []runner.HelpSection { return nil }
func (m *MockTool) StatsJSONFields(cfg *runner.Config) map[string]interface{} { return nil }
func (m *MockTool) UsesStreamOutput() bool { return false }
func (m *MockTool) RunLogFields(cfg *runner.Config) []string { return nil }


func TestGetStepModel(t *testing.T) {
	s := &settings.Settings{}
	o := New(s)
	
	// Inject mock tools specifically for this test if needed, 
	// or rely on the fact that New() creates real tools and we just test logic.
	// Since New() hardcodes tools, we can't easily inject mocks without refactoring.
	// Let's test the logic we can control.

	tests := []struct {
		name      string
		tool      string
		stepModel string
		opusOnly  bool
		flashOnly bool
		want      string
	}{
		{
			name:      "Explicit model",
			tool:      "claude",
			stepModel: "claude-3-sonnet",
			want:      "claude-3-sonnet",
		},
		{
			name:      "Opus only override",
			tool:      "claude",
			stepModel: "claude-3-sonnet",
			opusOnly:  true,
			want:      "opus",
		},
		{
			name:      "Flash only override",
			tool:      "gemini",
			stepModel: "gemini-1.5-pro",
			flashOnly: true,
			want:      "gemini-3-flash-preview",
		},
		{
			name:      "Tool default (mocked check)",
			tool:      "claude",
			stepModel: "",
			want:      "claude-3-5-sonnet-20241022", // Current default in source
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			o.SetOpusOnly(tt.opusOnly)
			o.SetFlashOnly(tt.flashOnly)
			got := o.getStepModel(tt.tool, tt.stepModel)
			if got != tt.want {
				t.Errorf("getStepModel() = %v, want %v", got, tt.want)
			}
		})
	}
}
```

---

# FIXES

### 1. Robust Scheduler
**Issue:** The Node.js scheduler lacks error handling and configuration.
**Fix:** Add error handling for file operations and make the command configurable.

```javascript
<<<<
const POLL_INTERVAL = 60000 // 60 seconds

const activeJobs = new Map()
====
const POLL_INTERVAL = 60000 // 60 seconds
const COMMAND = process.env.RCODEGEN_CMD || 'rcodex'

const activeJobs = new Map()
>>>>
```

```javascript
<<<<
function writeStatus() {
  ensureDir(STATUS_FILE)
  const status = {
    pid: process.pid,
    started: startTime.toISOString(),
    lastHeartbeat: new Date().toISOString(),
    recentRuns
  }
  fs.writeFileSync(STATUS_FILE, JSON.stringify(status, null, 2))
}
====
function writeStatus() {
  try {
    ensureDir(STATUS_FILE)
    const status = {
      pid: process.pid,
      started: startTime.toISOString(),
      lastHeartbeat: new Date().toISOString(),
      recentRuns
    }
    fs.writeFileSync(STATUS_FILE, JSON.stringify(status, null, 2))
  } catch (err) {
    console.error(`Error writing status file: ${err.message}`)
  }
}
>>>>
```

```javascript
<<<<
  // Spawn rcodex process
  const proc = spawn('rcodex', [schedule.task], {
    cwd: schedule.repo,
    stdio: 'inherit'
  })
====
  // Spawn process
  const proc = spawn(COMMAND, [schedule.task], {
    cwd: schedule.repo,
    stdio: 'inherit' // Note: Consider 'ignore' or pipe for background services
  })
>>>>
```

---

# REFACTOR

### 1. Decouple Orchestrator from Specific Tools
**Goal:** Remove hardcoded tool imports in `pkg/orchestrator/orchestrator.go`.
**Plan:**
1. Define a `ToolRegistry` interface.
2. Update `New()` to accept a `ToolRegistry` or a map of tools.
3. Move tool instantiation to `main.go` or a wire-up package.

### 2. Standardize Report Generation
**Goal:** Clean up the messy report generation logic.
**Plan:**
1. Create a `pkg/reporting` package.
2. Define struct tags or a mapping configuration for bundles to define their output artifacts.
3. Replace the huge `switch/if` blocks in `generateRunReport` with a data-driven approach.

### 3. Extract Grade Parsing
**Goal:** Centralize grade parsing logic which is currently duplicated or brittle.
**Plan:**
1. Ensure `pkg/runner/grades.go` is the single source of truth for parsing grades.
2. Use strict JSON unmarshaling instead of string searching where possible.
